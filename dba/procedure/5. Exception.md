[toc]

# Exception

## Type

### Predefined Oracle

oracle에 정의되어 있는 exception

---

### Non-Prefefined(User defined)

사용자가 직접 정의한 exception

#### raise

목적: 정상 종료 

실행절에서 exception code를 정의하고
예외처리부에서 정의된 exception code의 메시지를 출력
대신, exception code는 exception 데이터타입 선언 필요

#### raise_application_error

목적: 비정상 종료

실행절에서 바로 에러 처리(비정상 종료, ora code를 지정할 수 있음)

## Tutorial

> 더 이상 출력할 데이터가 없을 경우, ORA 에러 발생처리를
> 사용자가 지정한 메시지가 출력되면서 정상 프로시져를 종료시킴
>
> emp 테이블에서 사원번호를 입력받고,
> 상위관리자 이름과 상위관리자와의 급여차를 아래와 같은 형식으로 출력
>
> 관리자: scott, 급여차: 400

### case 1

#### 1. 작성

```sql
declare
  mgr_name  scott.emp.ename%type;
  gap       scott.emp.sal%type;
  
--  iempno scott.emp.empno%type := 7369; 	-- ✅
  iempno scott.emp.empno%type := 9999; 		-- 💥 no empno
--  iempno scott.emp.empno%type := 7839; 	-- 💥 no mgr
begin
  select e2.ename,
         abs(e2.sal - e1.sal)
    into mgr_name, gap
    from scott.emp e1, scott.emp e2
   where 1=1
     and e1.mgr = e2.empno
     and e1.empno = iempno;
  
  dbms_output.put_line('관리자: '||mgr_name||', 급여차: '||gap);
end;
/
```

#### 2. 예외 리스트업

```sql
💥 no empno
ORA-01403
💥 no mgr
ORA-01403
```

#### 3. 단순 예외 처리(Oracle Exception)

```sql
declare
  mgr_name  scott.emp.ename%type;
  gap       scott.emp.sal%type;
  
--  iempno scott.emp.empno%type := 7369; 	-- ✅
  iempno scott.emp.empno%type := 9999; 		-- 💥 no empno 	=> NO_DATA_FOUND
--  iempno scott.emp.empno%type := 7839; 	-- 💥 no mgr		=> NO_DATA_FOUND
begin
  select e2.ename,
         abs(e2.sal - e1.sal)
    into mgr_name, gap
    from scott.emp e1, scott.emp e2
   where 1=1
     and e1.mgr = e2.empno
     and e1.empno = iempno;
  
  dbms_output.put_line('관리자: '||mgr_name||', 급여차: '||gap);
  
exception
	when NO_DATA_FOUND then
  dbms_output.put_line('관리자가 없거나 해당 직원이 유효하지 않습니다.');
end;
/
```

#### 4. 상세 예외 처리(User define Exception)

```sql
declare
  mgr_name  scott.emp.ename%type;
  gap       scott.emp.sal%type;
  
--  iempno scott.emp.empno%type := 7369; 	-- ✅
  iempno scott.emp.empno%type := 9999; 		-- 💥 no empno		=> NOT_EXISTS_EMPLOYEE
--  iempno scott.emp.empno%type := 7839; 	-- 💥 no mgr			=> NOT_EXISTS_MANAGER
begin
  select e2.ename,
         abs(e2.sal - e1.sal)
    into mgr_name, gap
    from scott.emp e1, scott.emp e2
   where 1=1
     and e1.mgr = e2.empno
     and e1.empno = iempno;
  
  dbms_output.put_line('관리자: '||mgr_name||', 급여차: '||gap);
  
  exception
  	when NO_DATA_FOUND then
  	dbms_output.put_line('관리자가 없거나 해당 직원이 유효하지 않습니다.');
end;
/
```

### case 2

> student, professor 테이블에서 이용하여
> 입력받은 지도교수 번호에 해당하는 지도학생 수를 출력
> format: 나한열의 지도학생은 1명입니다.
> 단, 지도학생이 없는 경우는 에러처리(지도 학생이 없습니다.)

```sql
declare
--  vno           number := 1001;		-- ✅
  vno           number := 4004;			-- 💥 => raise no_student
  
  pname         scott.professor.name%type;
  std_cnt       number;
  no_student    exception;
begin
  select p.name, count(s.studno) into pname, std_cnt
    from professor p, student s
   where p.profno = s.profno(+)
     and p.profno = vno
   group by p.profno, p.name;
   
  if std_cnt = 0 then
    raise no_student;
  end if;
    
  dbms_output.put_line(pname||'의 지도학생은 '||std_cnt||'명입니다.');
  
exception 
  when no_student then
  dbms_output.put_line('지도학생이 없습니다');
end;
/
```

## 🎁 oracle exception code

** ora code: 20000~20999 사용가능하고, 마치 오라클 에러처럼 사용 가능

| name                    | code      | note                                                         |
| :---------------------- | :-------- | :----------------------------------------------------------- |
| DUP_VAL_ON_INDEX        | ORA-00001 | 유일인덱스에 중복값을 입력(Insert)하거나 업데이트(Update)하는 경우 발생되는 예외. |
| TIMEOUT_ON_RESOURCE     | ORA-00051 | 데이터베이스 자원을 기다리는 동안 타임아웃 발생 시 발생.     |
| TRANSACTION_BACKED_OUT  | ORA-00061 | 명시적으로 ROLLBACK을 실행했거나 다른 동작의 결과로 원격 트랜잭션 부분이 롤백되는 경우 |
| INVALID_CURSOR          | ORA-01001 | 존재하지 않는 커서를 참조하려 할 때 발생되는 예외. 일반적으로 커서 OPEN전에 FETCH하거나 CLOSE할때 발생 한다. |
| NOT_LOGGED_ON           | ORA-01012 | 오라클 RDBMS에 접속하기 전(로그인 전)에 데이터베이스를 호출하는 경우 발생. |
| LOGIN_DENIED            | ORA-01017 | 잘못된 사용자 이름이나 비밀번호로 로그인을 시도 하였을때 발생되는 예외. |
| NO_DATA_FOUND           | ORA-01403 | 결과가 없는 SELECT INTO문(묵시적 커서)을 실행할 때 발생되는 예외. PL/SQL 테이블의 초기화되지 않은 행을 참조할 때 발생되는 예외. 패키지 UTL_FILE로 파일의 내용이 끝난 다음에 내용을 읽어 들일 때 발생. |
| SYS_INVALID_ROWID       | ORA-01410 | 문자열을 ROWID로 변환할 때 무효한 문자열의 표현일 경우       |
| TOO_MANY_ROWS           | ORA-01422 | 하나 이상의 결과 값을 반환하는 SELECT INTO문을 실행한 경우. (SELECT INTO는 한 행만 반환할 수 있다.) |
| ZERO_DIVIDE             | ORA-01476 | 0으로 나눌 때 발생하는 오류.                                 |
| ZERO_DEVIDE             | ORA-01476 | 0으로 나누려했을 때 발생하는 예외                            |
| INVALID_NUMBER          | ORA-01722 | 문자열을 숫자로 변환하는 SQL문이 실패했을 경우 발생되는 예외. |
| STORAGE_ERROR           | ORA-06500 | 프로그램 수행 시 메모리가 부족할 경우(메모리 초과) 발생.     |
| PROGRAM_ERROR           | ORA-06501 | PL/SQL 코드상에서 내부 오류를 만났을 때 발생. 이 오류가 발생하면 "오라클에 문의(Contact Oracle Support)"란 메시지 출력. |
| VALUE_ERROR             | ORA-06502 | 수치 또는 값 오류.                                           |
| ROWTYPE_MISMATCH        | ORA-06504 | 할당문에서 호스트 커서 변수와 PL/SQL 커서 변수의 데이터 형이 불일치 할 때 발생되는 예외. |
| CURSOR_ALREADY_OPEN     | ORA-06511 | 이미 열려진 커서를 열려고 시도 했을 때 발생되는 예외. 커서를 OPEN하거나 재 OPEN하기 위해 커서를 CLOSE해야한다. |
| ACCESS_INTO_NULL        | ORA-06530 | 정의되지 않은 Obejct 속성에 Value을 할당 하고자 했을 때 발생되는 예외. 즉 객체 초기화 되지 않은 상태에서 사용했을떄 발생되는 예외. |
| COLLECTION_IS_NULL      | ORA-06531 | 선언되지 않은 컬렉션 (nested table, varray)에 EXISTS 이외의 메소드를 사용했을 때 발생되는 예외 |
| SUBSCRIPT_OUTSIDE_LIMIT | ORA-06532 | 컬렉션의 범위 밖의 참조가 일어났을 때 발생되는 예외.         |
| SUBSCRIPT_BEYOND_COUNT  | ORA-06533 | 컬렉션의 요소 개수보다 더 큰 첨자 값으로 참조한 경우 발생되는 예외. |
| CASE_NOT_FOUND          | ORA-06592 | CASE 문의 구문 오류. 예를 들어 CASE문의 WHEN 절에 해당되는 조건이 없고 ELSE 절도 없을 경우에 발생되는 예외. |

