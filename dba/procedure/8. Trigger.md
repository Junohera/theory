[toc]

# Trigger

[oracle trigger documentation](https://docs.oracle.com/cd/E17781_01/appdev.112/e18147/tdddg_triggers.htm#TDDDG51000)

어떤 행위 전/후/대신 수행되는 작업 정의

> 접속기록: 접속 후 (username, ip, host)을 insert
> 접속해제기록: 접속해제 전 (username, ip, host)을 insert

행위 종류에 따라: dml, ddl, database 트리거로 구분
select의 경우, 직접적으로 triggering 할 수없어 간접적으로 trigger 해야함.

💥주의사항
function/trigger를 통해 수정시 old value와 new value를 구분하지 않으면
dml 수행 불가(같은 데이터를 열어두고 수정하는 행위에 대해 에러 처리)

## syntax

```sql
create [or replace] trigger 트리거명 
timing 
	before|after|instead of [event1 or event2 or event3 … ] 
	on {table_name|view_name|schema|database} 
[referencing old as old | new as new] 
[for each row [when ( condition ) ] ] 
trigger_body
;
```

## management

### 1. describe

```sql
select * from dba_objects where object_type = 'TRIGGER';
select * from dba_triggers;
```

### 2. on/off a single trigger

```sql
alter trigger $TRIGGER_NAME disable;
alter trigger $TRIGGER_NAME enable;
```

### 3. on/off triggers on a single table

```sql
alter table $TABLE_NAME disable all triggers;
alter table $TABLE_NAME enable all triggers;
```

## usage

### 1. database event trigger

#### logon

```sql
-- 유저 정보 조회
select sys_context('USERENV', 'IP_ADDRESS')   as ip,
			 sys_context('USERENV', 'SESSIONID')    as sessionid,
			 sys_context('USERENV', 'HOST')         as host,
			 sys_context('USERENV', 'TERMINAL')     as device
	from dual;
	
-- 테이블 생성
create table scott.log_on
( userid    varchar2(64),
  ip_addr   varchar2(64),
  host      varchar2(64),
  created   timestamp);
			 
-- log on 트리거 생성
create or replace trigger t_loggon
after logon on database
begin
	insert into log_on values (
  user,
  sys_context('USERENV', 'IP_ADDRESS'),
  sys_context('USERENV', 'TERMINAL'),
  systimestamp);
  commit;
end;
/
```

#### logon/off

> log_on: insert
> log_off: update

```sql
-- 유저 정보 조회
select sys_context('USERENV', 'IP_ADDRESS')   as ip,
			 sys_context('USERENV', 'SESSIONID')    as sessionid,
			 sys_context('USERENV', 'HOST')         as host,
			 sys_context('USERENV', 'TERMINAL')     as device
	from dual;

drop table log_on_off purge;
create table log_on_off
( session_id    number,
  userid        varchar2(64),
  ip            varchar2(64),
  host          varchar2(64),
  device        varchar2(64),
  joined        timestamp,
  leaved        timestamp
);

create or replace trigger t_loggon
after logon on database
begin
	insert into log_on_off (
  session_id,
  userid,
  ip,
  host,
  device,
  joined)
  values (
  sys_context('USERENV', 'SESSIONID'),
  user,
  sys_context('USERENV', 'IP_ADDRESS'),
  sys_context('USERENV', 'HOST'),
  sys_context('USERENV', 'TERMINAL'),
  systimestamp
  );
  commit;
end;
/

create or replace trigger t_loggoff
before logoff on database
begin
	update log_on_off
     set leaved = systimestamp
   where session_id = sys_context('USERENV', 'SESSIONID');
  commit;
end;
/
select *
  from log_on_off;
```

#### access authorization trigger

```sql
select username,
       created
  from dba_users
 where default_tablespace = 'USERS'
   and trunc(sysdate - created) = 0
 order by created;

drop user black_list_1_no_create_session;
drop user black_list_2_privilege;
create user black_list_1_no_create_session identified by oracle;
create user black_list_2_privilege identified by oracle;
--grant create session to black_list_1_no_create_session;
grant create session to black_list_2_privilege;

drop trigger t_loggon;
drop trigger t_loggoff;
drop table log_on_off purge;

create table log_on_off
( session_id    number,
  userid        varchar2(64),
  ip            varchar2(64),
  host          varchar2(64),
  device        varchar2(64),
 	status				varchar2(8),
  joined        timestamp,
  leaved        timestamp
);

create or replace trigger t_loggon
after logon on database
begin
	if upper(user) in (
    'BLACK_LIST_1_NO_CREATE_SESSION', 
    'BLACK_LIST_2_PRIVILEGE'
  ) then
    insert into log_on_off (session_id, userid, ip, host, device, status, joined)
    values (sys_context('USERENV', 'SESSIONID'),
				    user,
            sys_context('USERENV', 'IP_ADDRESS'),
            sys_context('USERENV', 'HOST'),
            sys_context('USERENV', 'TERMINAL'),
            'DENIED',
            systimestamp);
    commit;
  	raise_application_error(-20403, '승인되지 않은 사용자입니다.('||upper(user)||')');
  else
  	insert into log_on_off (session_id, userid, ip, host, device, status, joined)
    values (sys_context('USERENV', 'SESSIONID'),
            user,
            sys_context('USERENV', 'IP_ADDRESS'),
            sys_context('USERENV', 'HOST'),
            sys_context('USERENV', 'TERMINAL'),
            'SUCCESS',
            systimestamp);
    commit;
    dbms_output.put_line('접속이 허가되었습니다. welcome');
  end if;
end;
/

create or replace trigger t_loggoff
before logoff on database
begin
	update log_on_off
     set leaved = systimestamp
   where session_id = sys_context('USERENV', 'SESSIONID');
  commit;
end;
/

select *
  from log_on_off
 order by joined desc;
```

### 2. dml event trigger

특정 테이블에 대해 dml발생시 dml에 대한 기록을 하는 트리거 작성

```sql
drop table student2 purge;
drop table delete_std2_log purge;
drop table update_std2_log purge;
drop table insert_std2_log purge;

create table student2 as select * from student;
create table delete_std2_log as select s.*, sysdate as processed from student s where 1=2; 
create table update_std2_log as select s.*, sysdate as processed from student s where 1=2;
create table insert_std2_log as select s.*, sysdate as processed from student s where 1=2;

alter table update_std2_log add type char(3);

select * from delete_std2_log;
select * from update_std2_log;
select * from insert_std2_log;
```

#### delete

```sql
create or replace trigger delete_std2
after delete on student2
for each row
begin
	insert into delete_std2_log
	values(
  :old.studno, 
  :old.name, :old.id, :old.grade, :old.jumin,
  :old.birthday, :old.tel, :old.height, :old.weight,
  :old.deptno1, :old.deptno2, :old.profno, :old.hakjum,
  sysdate
  );
end;
/

delete from student2
 where studno = 9411;
commit;

select *
  from delete_std2_log;
```

#### update

```sql
create or replace trigger update_before_std2
before update on student2
for each row
begin
	insert into update_std2_log
	values(
  :old.studno, 
  :old.name, :old.id, :old.grade, :old.jumin,
  :old.birthday, :old.tel, :old.height, :old.weight,
  :old.deptno1, :old.deptno2, :old.profno, :old.hakjum,
  sysdate, 'OLD'
  );
end;
/

create or replace trigger update_after_std2
after update on student2
for each row
begin
	insert into update_std2_log
	values(
  :new.studno, 
  :new.name, :new.id, :new.grade, :new.jumin,
  :new.birthday, :new.tel, :new.height, :new.weight,
  :new.deptno1, :new.deptno2, :new.profno, :new.hakjum,
  sysdate, 'NEW'
  );
end;
/

update student2
   set name = name||'TEST'
 where studno = 9413;
 commit;
 
select *
  from update_std2_log;
```

#### insert

```sql
create or replace trigger insert_std2
after insert on student2
for each row
begin
	insert into insert_std2_log
	values(
  :new.studno, 
  :new.name, :new.id, :new.grade, :new.jumin,
  :new.birthday, :new.tel, :new.height, :new.weight,
  :new.deptno1, :new.deptno2, :new.profno, :new.hakjum,
  sysdate
  );
end;
/

insert into student2
select studno,
       name,
       id,
       grade,
       jumin,
       birthday,
       tel,
       height,
       weight,
       deptno1,
       deptno2,
       profno,
       hakjum
  from delete_std2_log where studno = 9412;
commit;

select *
  from insert_std2_log;
```

#### I/U/D

```sql
-- pre
drop table student3 purge;
create table student3 as select * from student;

drop table audit_log_student3 purge;
create table audit_log_student3 as
select 1 as audit_id,
			 'CREATE' as audit_type,
       sysdate as audit_processed, 
       s.*
  from student s
 where 1=2;
select * from audit_log_student3;

drop sequence seq_audit_log_student3;
create sequence seq_audit_log_student3;

-- define trigger
create or replace trigger trg_audit_at_student3
after insert or update or delete on student3
for each row
begin
	if INSERTING then    
    insert into audit_log_student3
    values(seq_audit_log_student3.nextval, 'INSERT', sysdate,
           :new.studno, :new.name, :new.id, :new.grade, :new.jumin, :new.birthday, :new.tel, :new.height, :new.weight, :new.deptno1, :new.deptno2, :new.profno, :new.hakjum);
  elsif UPDATING then    
    insert into audit_log_student3
    values(seq_audit_log_student3.nextval, 'UPDATE', sysdate,
           :new.studno, :new.name, :new.id, :new.grade, :new.jumin, :new.birthday, :new.tel, :new.height, :new.weight, :new.deptno1, :new.deptno2, :new.profno, :new.hakjum);
  elsif DELETING then    
    insert into audit_log_student3
    values(seq_audit_log_student3.nextval, 'DELETE', sysdate,
           :old.studno, :old.name, :old.id, :old.grade, :old.jumin, :old.birthday, :old.tel, :old.height, :old.weight, :old.deptno1, :old.deptno2, :old.profno, :old.hakjum);
  else
    dbms_output.put_line('this code is not reachable.');
  end if;
  
end;
/

-- trigger test
insert into student3 values (9999, 'NAME', 'RETURNTRUE', 4, '7510231901813', sysdate, '055)381-2158', 180, 72, 101, 201, 1001, null);
commit;
update student3
   set name = 'TEST'
 where studno = 9999;
commit;
delete from student3
 where studno = 9999;
commit;

-- check
select *
   from audit_log_student3
 order by audit_processed asc;
```



