[toc]

# Trigger

> ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë°œìƒí•˜ëŠ” íŠ¹ì • ì´ë²¤íŠ¸ì— ìë™ìœ¼ë¡œ ì‘ë‹µí•˜ì—¬ ì‹¤í–‰ë˜ëŠ” ì €ì¥ í”„ë¡œì‹œì €(stored procedure)ì…ë‹ˆë‹¤. 
> ì´ë²¤íŠ¸ëŠ” ë°ì´í„°ì˜ ë³€ê²½, ì‚½ì…, ì—…ë°ì´íŠ¸, ì‚­ì œ ë“±ê³¼ ê´€ë ¨ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> íŠ¸ë¦¬ê±°ëŠ” ì£¼ë¡œ ë°ì´í„°ì˜ **ì¼ê´€ì„± ìœ ì§€, ë³´ì•ˆ ì œì–´, ë¡œê¹…** ë“±ì„ ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.

---

[oracle trigger documentation](https://docs.oracle.com/cd/E17781_01/appdev.112/e18147/tdddg_triggers.htm#TDDDG51000)

ì–´ë–¤ í–‰ìœ„ ì „/í›„/ëŒ€ì‹  ìˆ˜í–‰ë˜ëŠ” ì‘ì—… ì •ì˜

> ì ‘ì†ê¸°ë¡: ì ‘ì† í›„ (username, ip, host)ì„ insert
> ì ‘ì†í•´ì œê¸°ë¡: ì ‘ì†í•´ì œ ì „ (username, ip, host)ì„ insert

í–‰ìœ„ ì¢…ë¥˜ì— ë”°ë¼: dml, ddl, database íŠ¸ë¦¬ê±°ë¡œ êµ¬ë¶„
selectì˜ ê²½ìš°, ì§ì ‘ì ìœ¼ë¡œ triggering í•  ìˆ˜ì—†ì–´ ê°„ì ‘ì ìœ¼ë¡œ trigger í•´ì•¼í•¨.

ğŸ’¥ì£¼ì˜ì‚¬í•­
function/triggerë¥¼ í†µí•´ ìˆ˜ì •ì‹œ old valueì™€ new valueë¥¼ êµ¬ë¶„í•˜ì§€ ì•Šìœ¼ë©´
dml ìˆ˜í–‰ ë¶ˆê°€(ê°™ì€ ë°ì´í„°ë¥¼ ì—´ì–´ë‘ê³  ìˆ˜ì •í•˜ëŠ” í–‰ìœ„ì— ëŒ€í•´ ì—ëŸ¬ ì²˜ë¦¬)

## syntax

```sql
create [or replace] trigger íŠ¸ë¦¬ê±°ëª… 
timing 
	before|after|instead of [event1 or event2 or event3 â€¦ ] 
	on {table_name|view_name|schema|database} 
[referencing old as old | new as new] 
[for each row [when ( condition ) ] ] 
trigger_body
;
```

## management

### 1. describe

```sql
select * from dba_objects where object_type = 'TRIGGER';
select * from dba_triggers;
```

### 2. on/off a single trigger

```sql
alter trigger $TRIGGER_NAME disable;
alter trigger $TRIGGER_NAME enable;
```

### 3. on/off triggers on a single table

```sql
alter table $TABLE_NAME disable all triggers;
alter table $TABLE_NAME enable all triggers;
```

## usage

### 1. database event trigger

#### logon

```sql
-- ìœ ì € ì •ë³´ ì¡°íšŒ
select sys_context('USERENV', 'IP_ADDRESS')   as ip,
			 sys_context('USERENV', 'SESSIONID')    as sessionid,
			 sys_context('USERENV', 'HOST')         as host,
			 sys_context('USERENV', 'TERMINAL')     as device
	from dual;
	
-- í…Œì´ë¸” ìƒì„±
create table scott.log_on
( userid    varchar2(64),
  ip_addr   varchar2(64),
  host      varchar2(64),
  created   timestamp);
			 
-- log on íŠ¸ë¦¬ê±° ìƒì„±
create or replace trigger t_loggon
after logon on database
begin
	insert into log_on values (
  user,
  sys_context('USERENV', 'IP_ADDRESS'),
  sys_context('USERENV', 'TERMINAL'),
  systimestamp);
  commit;
end;
/
```

#### logon/off

> log_on: insert
> log_off: update

```sql
-- ìœ ì € ì •ë³´ ì¡°íšŒ
select sys_context('USERENV', 'IP_ADDRESS')   as ip,
			 sys_context('USERENV', 'SESSIONID')    as sessionid,
			 sys_context('USERENV', 'HOST')         as host,
			 sys_context('USERENV', 'TERMINAL')     as device
	from dual;

drop table log_on_off purge;
create table log_on_off
( session_id    number,
  userid        varchar2(64),
  ip            varchar2(64),
  host          varchar2(64),
  device        varchar2(64),
  joined        timestamp,
  leaved        timestamp
);

create or replace trigger t_loggon
after logon on database
begin
	insert into log_on_off (
  session_id,
  userid,
  ip,
  host,
  device,
  joined)
  values (
  sys_context('USERENV', 'SESSIONID'),
  user,
  sys_context('USERENV', 'IP_ADDRESS'),
  sys_context('USERENV', 'HOST'),
  sys_context('USERENV', 'TERMINAL'),
  systimestamp
  );
  commit;
end;
/

create or replace trigger t_loggoff
before logoff on database
begin
	update log_on_off
     set leaved = systimestamp
   where session_id = sys_context('USERENV', 'SESSIONID');
  commit;
end;
/
select *
  from log_on_off;
```

#### access authorization trigger

```sql
select username,
       created
  from dba_users
 where default_tablespace = 'USERS'
   and trunc(sysdate - created) = 0
 order by created;

drop user black_list_1_no_create_session;
drop user black_list_2_privilege;
create user black_list_1_no_create_session identified by oracle;
create user black_list_2_privilege identified by oracle;
--grant create session to black_list_1_no_create_session;
grant create session to black_list_2_privilege;

drop trigger t_loggon;
drop trigger t_loggoff;
drop table log_on_off purge;

create table log_on_off
( session_id    number,
  userid        varchar2(64),
  ip            varchar2(64),
  host          varchar2(64),
  device        varchar2(64),
 	status				varchar2(8),
  joined        timestamp,
  leaved        timestamp
);

create or replace trigger t_loggon
after logon on database
begin
	if upper(user) in (
    'BLACK_LIST_1_NO_CREATE_SESSION', 
    'BLACK_LIST_2_PRIVILEGE'
  ) then
    insert into log_on_off (session_id, userid, ip, host, device, status, joined)
    values (sys_context('USERENV', 'SESSIONID'),
				    user,
            sys_context('USERENV', 'IP_ADDRESS'),
            sys_context('USERENV', 'HOST'),
            sys_context('USERENV', 'TERMINAL'),
            'DENIED',
            systimestamp);
    commit;
  	raise_application_error(-20403, 'ìŠ¹ì¸ë˜ì§€ ì•Šì€ ì‚¬ìš©ìì…ë‹ˆë‹¤.('||upper(user)||')');
  else
  	insert into log_on_off (session_id, userid, ip, host, device, status, joined)
    values (sys_context('USERENV', 'SESSIONID'),
            user,
            sys_context('USERENV', 'IP_ADDRESS'),
            sys_context('USERENV', 'HOST'),
            sys_context('USERENV', 'TERMINAL'),
            'SUCCESS',
            systimestamp);
    commit;
    dbms_output.put_line('ì ‘ì†ì´ í—ˆê°€ë˜ì—ˆìŠµë‹ˆë‹¤. welcome');
  end if;
end;
/

create or replace trigger t_loggoff
before logoff on database
begin
	update log_on_off
     set leaved = systimestamp
   where session_id = sys_context('USERENV', 'SESSIONID');
  commit;
end;
/

select *
  from log_on_off
 order by joined desc;
```

### 2. dml event trigger

íŠ¹ì • í…Œì´ë¸”ì— ëŒ€í•´ dmlë°œìƒì‹œ dmlì— ëŒ€í•œ ê¸°ë¡ì„ í•˜ëŠ” íŠ¸ë¦¬ê±° ì‘ì„±

```sql
drop table student2 purge;
drop table delete_std2_log purge;
drop table update_std2_log purge;
drop table insert_std2_log purge;

create table student2 as select * from student;
create table delete_std2_log as select s.*, sysdate as processed from student s where 1=2; 
create table update_std2_log as select s.*, sysdate as processed from student s where 1=2;
create table insert_std2_log as select s.*, sysdate as processed from student s where 1=2;

alter table update_std2_log add type char(3);

select * from delete_std2_log;
select * from update_std2_log;
select * from insert_std2_log;
```

#### delete

```sql
create or replace trigger delete_std2
after delete on student2
for each row
begin
	insert into delete_std2_log
	values(
  :old.studno, 
  :old.name, :old.id, :old.grade, :old.jumin,
  :old.birthday, :old.tel, :old.height, :old.weight,
  :old.deptno1, :old.deptno2, :old.profno, :old.hakjum,
  sysdate
  );
end;
/

delete from student2
 where studno = 9411;
commit;

select *
  from delete_std2_log;
```

#### update

```sql
create or replace trigger update_before_std2
before update on student2
for each row
begin
	insert into update_std2_log
	values(
  :old.studno, 
  :old.name, :old.id, :old.grade, :old.jumin,
  :old.birthday, :old.tel, :old.height, :old.weight,
  :old.deptno1, :old.deptno2, :old.profno, :old.hakjum,
  sysdate, 'OLD'
  );
end;
/

create or replace trigger update_after_std2
after update on student2
for each row
begin
	insert into update_std2_log
	values(
  :new.studno, 
  :new.name, :new.id, :new.grade, :new.jumin,
  :new.birthday, :new.tel, :new.height, :new.weight,
  :new.deptno1, :new.deptno2, :new.profno, :new.hakjum,
  sysdate, 'NEW'
  );
end;
/

update student2
   set name = name||'TEST'
 where studno = 9413;
 commit;
 
select *
  from update_std2_log;
```

#### insert

```sql
create or replace trigger insert_std2
after insert on student2
for each row
begin
	insert into insert_std2_log
	values(
  :new.studno, 
  :new.name, :new.id, :new.grade, :new.jumin,
  :new.birthday, :new.tel, :new.height, :new.weight,
  :new.deptno1, :new.deptno2, :new.profno, :new.hakjum,
  sysdate
  );
end;
/

insert into student2
select studno,
       name,
       id,
       grade,
       jumin,
       birthday,
       tel,
       height,
       weight,
       deptno1,
       deptno2,
       profno,
       hakjum
  from delete_std2_log where studno = 9412;
commit;

select *
  from insert_std2_log;
```

#### I/U/D

```sql
-- pre
drop table student3 purge;
create table student3 as select * from student;

drop table audit_log_student3 purge;
create table audit_log_student3 as
select 1 as audit_id,
			 'CREATE' as audit_type,
       sysdate as audit_processed, 
       s.*
  from student s
 where 1=2;
select * from audit_log_student3;

drop sequence seq_audit_log_student3;
create sequence seq_audit_log_student3;

-- define trigger
create or replace trigger trg_audit_at_student3
after insert or update or delete on student3
for each row
begin
	if INSERTING then    
    insert into audit_log_student3
    values(seq_audit_log_student3.nextval, 'INSERT', sysdate,
           :new.studno, :new.name, :new.id, :new.grade, :new.jumin, :new.birthday, :new.tel, :new.height, :new.weight, :new.deptno1, :new.deptno2, :new.profno, :new.hakjum);
  elsif UPDATING then    
    insert into audit_log_student3
    values(seq_audit_log_student3.nextval, 'UPDATE', sysdate,
           :new.studno, :new.name, :new.id, :new.grade, :new.jumin, :new.birthday, :new.tel, :new.height, :new.weight, :new.deptno1, :new.deptno2, :new.profno, :new.hakjum);
  elsif DELETING then    
    insert into audit_log_student3
    values(seq_audit_log_student3.nextval, 'DELETE', sysdate,
           :old.studno, :old.name, :old.id, :old.grade, :old.jumin, :old.birthday, :old.tel, :old.height, :old.weight, :old.deptno1, :old.deptno2, :old.profno, :old.hakjum);
  else
    dbms_output.put_line('this code is not reachable.');
  end if;
  
end;
/

-- trigger test
insert into student3 values (9999, 'NAME', 'RETURNTRUE', 4, '7510231901813', sysdate, '055)381-2158', 180, 72, 101, 201, 1001, null);
commit;
update student3
   set name = 'TEST'
 where studno = 9999;
commit;
delete from student3
 where studno = 9999;
commit;

-- check
select *
   from audit_log_student3
 order by audit_processed asc;
```

### 3. FK ëŒ€ì²´

> FKë¥¼ í†µí•´ ë¶€ëª¨/ìì‹ì˜ ê´€ê³„ë¥¼ ì„¤ê³„í•  ê²½ìš°,
> ë¶€ëª¨ëŠ” update, deleteì‹œ ì œí•œì´ ìƒê¸°ê³ 
> ìì‹ì€ insertì‹œ ì œí•œì´ ìƒê¸´ë‹¤.
>
> FKë¡œ ì¸í•´ ìœ„ì˜ ìƒí™©ì´ ìœ ì§€ë˜ëŠ” ê²ƒì„ ì›í•˜ì§€ ì•Šì„ ê²½ìš°, triggerë¥¼ í†µí•´ FKë¥¼ ëŒ€ì²´í•˜ì—¬ ì œì•½ì¡°ê±´ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.

| ë¶€ëª¨ì˜ update ì œí•œ | ë¶€ëª¨ì˜ delete ì œí•œ | ìì‹ì˜ insert ì œí•œ | ìì‹ì˜ update ì œí•œ | solution |
| ------------------ | ------------------ | ------------------ | ------------------ | -------- |
| Y                  | Y                  | Y                  | Y                  | FK       |
| N                  | N                  | Y                  | Y                  | Trigger  |
| Y\|N               | Y\|N               | Y\|N               | Y\|N               | Trigger  |

#### 1. Foreign Key

```sql
create table emp_test2 as select * from emp;
create table dept_test2 as select * from dept;

alter table dept_test2 add constraint pk_dept_test2_deptno
primary key(deptno);
alter table emp_test2 add constraint fk_emp_test2_deptno
foreign key(deptno) references dept_test2(deptno);

select * from dba_constraints where table_name in ('EMP_TEST2', 'DEPT_TEST2');
select * from dba_constraints where table_name in ('EMP', 'DEPT');

-- âœ… success
insert into emp_test2 (EMPNO, ENAME, DEPTNO) 
values (201, 'SUCCESS', 10);
insert into emp_test2 (EMPNO, ENAME, DEPTNO) 
values (400, 'FAILURE', 99); -- ğŸ’¥ ìì‹ ì…ë ¥ ì œí•œ
delete from dept_test2
 where deptno = 10; -- ğŸ’¥ ë¶€ëª¨ ì‚­ì œ ì œí•œ
update dept_test2
   set deptno = 99
 where deptno = 10; -- ğŸ’¥ ë¶€ëª¨ ìˆ˜ì • ì œí•œ
select * from emp_test2 where ename in ('SUCCESS', 'FAILURE');

rollback;
```

##### 1-1. when drop column(cascade constraints)

```sql
alter table dept_test2 drop column deptno cascade constraints;
select * from dba_constraints where table_name in ('EMP_TEST2', 'DEPT_TEST2');
```

##### 1-2. delete(on delete [CASCADE | SET NULL])

```sql
drop table emp_test2 purge;
drop table dept_test2 purge;
create table emp_test2 as select * from emp;
create table dept_test2 as select * from dept;
alter table dept_test2 add constraint pk_dept_test2_deptno
primary key(deptno);

-- default(on delete restrict)
alter table emp_test2 add constraint fk_emp_test2_deptno foreign key(deptno) references dept_test2(deptno);
delete from dept_test2 
 where deptno = 10;
update dept_test2
   set deptno = 99
 where deptno = 10;
 
-- cascade
alter table emp_test2 add constraint fk_emp_test2_deptno foreign key(deptno) references dept_test2(deptno)
on delete cascade;
delete from dept_test2 
 where deptno = 10;
select * from emp_test2 where deptno = 10;
-- set null
alter table emp_test2 add constraint fk_emp_test2_deptno foreign key(deptno) references dept_test2(deptno)
on delete set null;
delete from dept_test2 
 where deptno = 10;
select * from emp_test2 where deptno is null;
```

#### 2. Trigger

```sql
create table emp_test1 as select * from emp;
create table dept_test1 as select * from dept;

select *
  from dba_constraints
 where table_name in ('EMP_TEST1', 'DEPT_TEST1');
 
select *
  from dba_constraints
 where table_name in ('EMP', 'DEPT');
 
create or replace trigger trg_emp_test1_deptno_as_fk
before insert on emp_test1
for each row
  declare 
    vdeptno dept_test1.deptno%type;
  begin
    select deptno
      into vdeptno
      from dept_test1
     where deptno = :new.deptno;

  exception
    when NO_DATA_FOUND then
      raise_application_error(-20400,'í•´ë‹¹ ë¶€ì„œ ë²ˆí˜¸('||:new.deptno||')ëŠ” ìœ íš¨í•˜ì§€ ì•Šì€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë¶€ì„œë²ˆí˜¸ì…ë‹ˆë‹¤.');
    when others then
      raise_application_error(-20500,'UNKNOWN FATAL ERROR');
  end;
/

-- âœ… ìì‹ì˜ insert ì œí•œ í™•ì¸
insert into emp_test1 (EMPNO, ENAME, DEPTNO) 
values (201, 'SUCCESS', 10);
insert into emp_test1 (EMPNO, ENAME, DEPTNO) 
values (400, 'FAILURE', 99); -- ğŸ’¥ ìì‹ì˜ insert ì œí•œ
select * from emp_test1 where ename in ('SUCCESS', 'FAILURE');

-- âœ… ë¶€ëª¨ì˜ delete ì œí•œ í™•ì¸
delete from dept_test1
 where deptno = 10;
select * from emp_test1 where deptno = 10;
select * from dept_test1 where deptno = 10;
rollback;
```

---

## Transaction

### Transaction Isolation Level
#### 1. READ UNCOMMITTED
ê°€ì¥ ë‚®ì€ ê²©ë¦¬ ìˆ˜ì¤€.
í•˜ë‚˜ì˜ íŠ¸ëœì­ì…˜ì—ì„œ ë³€ê²½ëœ ë°ì´í„°ê°€ ì•„ì§ ì»¤ë°‹ë˜ì§€ ì•Šì•˜ë”ë¼ë„ ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì—ì„œ í•´ë‹¹ ë°ì´í„°ë¥¼ ë³¼ ìˆ˜ ìˆìŒ.
Dirty Readì™€ Non-repeatable Read ë¬¸ì œ ë°œìƒ ê°€ëŠ¥.

#### 2. READ COMMITTED
ëŒ€ë¶€ë¶„ì˜ ë°ì´í„°ë² ì´ìŠ¤ ì‹œìŠ¤í…œì˜ ê¸°ë³¸ ê²©ë¦¬ ìˆ˜ì¤€.
ì»¤ë°‹ëœ ë°ì´í„°ë§Œ ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì—ì„œ ë³¼ ìˆ˜ ìˆìŒ.
Dirty ReadëŠ” ë°©ì§€ë˜ì§€ë§Œ Non-repeatable Read ë¬¸ì œ ë°œìƒ ê°€ëŠ¥.

#### 3. REPEATABLE READ
ë™ì¼í•œ ì¿¼ë¦¬ë¥¼ ì‹¤í–‰í•˜ë”ë¼ë„ íŠ¸ëœì­ì…˜ ë‚´ì—ì„œ ì¡°íšŒí•œ ë°ì´í„°ëŠ” í•­ìƒ ë™ì¼í•¨.
íŠ¸ëœì­ì…˜ì´ ëë‚  ë•Œê¹Œì§€ ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì—ì„œ í•´ë‹¹ ë°ì´í„°ì— ëŒ€í•œ ë³€ê²½ì„ ë°©ì§€í•¨.
Phantom Read ë¬¸ì œ ë°œìƒ ê°€ëŠ¥ì„±ì´ ìˆìŒ.

#### 4. SERIALIZABLE
ê°€ì¥ ë†’ì€ ê²©ë¦¬ ìˆ˜ì¤€.
íŠ¸ëœì­ì…˜ ê°„ì˜ ì¶©ëŒì„ ì™„ì „íˆ í”¼í•˜ê¸° ìœ„í•´ ëª¨ë“  ë°ì´í„° ì ‘ê·¼ì„ ì§ë ¬í™”í•˜ì—¬ ì²˜ë¦¬í•¨.

Dirty Read, Non-repeatable Read, Phantom Read ëª¨ë‘ ë°©ì§€ë¨.
ê²©ë¦¬ ìˆ˜ì¤€ì´ ë†’ì„ìˆ˜ë¡ ë°ì´í„°ì˜ ì¼ê´€ì„±ì€ ë³´ì¥ë˜ì§€ë§Œ, ë™ì‹œì„±ê³¼ ì„±ëŠ¥ì´ ì €í•˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë”°ë¼ì„œ ê²©ë¦¬ ìˆ˜ì¤€ì„ ì„ íƒí•  ë•ŒëŠ” ë°ì´í„°ì˜ ì¼ê´€ì„±ê³¼ ë™ì‹œì„± ìš”êµ¬ ì‚¬í•­ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤.
ê¸°ë³¸ì ìœ¼ë¡œ ì˜¤ë¼í´ ë°ì´í„°ë² ì´ìŠ¤ëŠ” READ COMMITTED ê²©ë¦¬ ìˆ˜ì¤€ì„ ì‚¬ìš©í•˜ì§€ë§Œ, í•„ìš”ì— ë”°ë¼ ë‹¤ë¥¸ ê²©ë¦¬ ìˆ˜ì¤€ìœ¼ë¡œ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ê²©ë¦¬ ìˆ˜ì¤€ì€ SET TRANSACTION ISOLATION LEVEL ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### íŠ¸ë¦¬ê±°ì™€ ê²©ë¦¬ ìˆ˜ì¤€ì˜ ê´€ê³„
íŠ¸ë¦¬ê±°ëŠ” íŠ¹ì • ë°ì´í„° ë³€ê²½ ì‘ì—…ì´ ë°œìƒí•  ë•Œ ìë™ìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ”ë°, ì´ ë•Œ ê²©ë¦¬ ìˆ˜ì¤€ì´ ì¤‘ìš”í•œ ì—­í• ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
íŠ¸ë¦¬ê±° ë‚´ì—ì„œ ì‹¤í–‰ë˜ëŠ” SQL ë¬¸ì€ íŠ¸ë¦¬ê±°ë¥¼ í™œì„±í™”ì‹œí‚¨ íŠ¸ëœì­ì…˜ì˜ ê²©ë¦¬ ìˆ˜ì¤€ê³¼ ë™ì¼í•œ ê²©ë¦¬ ìˆ˜ì¤€ì„ ê°€ì§‘ë‹ˆë‹¤.
ë”°ë¼ì„œ ê²©ë¦¬ ìˆ˜ì¤€ì— ë”°ë¼ íŠ¸ë¦¬ê±°ê°€ ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ë°ì´í„°ì˜ ë²”ìœ„ì™€ ì–´ë–¤ ë°ì´í„°ë¥¼ ë³´ê²Œ ë˜ëŠ”ì§€ê°€ ì˜í–¥ì„ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### íŠ¸ë¦¬ê±°ì™€ ê²©ë¦¬ ìˆ˜ì¤€ì˜ ì¼ê´€ì„± ìœ ì§€
íŠ¸ë¦¬ê±°ëŠ” ë°ì´í„° ë³€ê²½ ì‘ì—…ì˜ ì¼ê´€ì„±ì„ ìœ ì§€í•˜ê³  ë³´ì¥í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
íŠ¸ë¦¬ê±°ëŠ” ë°ì´í„° ë³€ê²½ ì‘ì—…ì„ ê°ì§€í•˜ê³  ì´ì— ëŒ€í•œ ì¶”ê°€ì ì¸ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
íŠ¸ë¦¬ê±° ë‚´ì—ì„œ ë³€ê²½ëœ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ë•Œ ê²©ë¦¬ ìˆ˜ì¤€ì„ ê³ ë ¤í•˜ì—¬ ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ê³¼ì˜ ìƒí˜¸ì‘ìš©ì„ ì œì–´í•´ì•¼ í•©ë‹ˆë‹¤.
íŠ¸ë¦¬ê±° ë‚´ì—ì„œ ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬ë‚˜ í”„ë¡œì‹œì €ë„ ê²©ë¦¬ ìˆ˜ì¤€ì— ë§ê²Œ ì¼ê´€ì„±ì„ ìœ ì§€í•  í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.
### íŠ¸ë¦¬ê±°ì˜ ì‹¤í–‰ ì‹œì ê³¼ ê²©ë¦¬ ìˆ˜ì¤€
íŠ¸ë¦¬ê±°ëŠ” ë°ì´í„° ë³€ê²½ ì‘ì—…ì´ ë°œìƒí•œ í›„ ì‹¤í–‰ë˜ë¯€ë¡œ, í•´ë‹¹ íŠ¸ëœì­ì…˜ì˜ ê²©ë¦¬ ìˆ˜ì¤€ì— ë”°ë¼ íŠ¸ë¦¬ê±° ë‚´ì—ì„œ ì‚¬ìš©ë˜ëŠ” ë°ì´í„°ì˜ ìƒíƒœê°€ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 íŠ¸ë¦¬ê±°ì—ì„œ ì¡°íšŒëœ ë°ì´í„°ì˜ ë³€ê²½ ì—¬ë¶€ë‚˜ ì¼ê´€ì„±ì„ íŒë‹¨í•˜ê¸° ìœ„í•´ì„œëŠ” íŠ¸ë¦¬ê±°ë¥¼ ì‹¤í–‰í•˜ëŠ” ì‹œì ì— ì ìš©ë˜ëŠ” ê²©ë¦¬ ìˆ˜ì¤€ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤.
íŠ¸ë¦¬ê±°ì™€ ê²©ë¦¬ ìˆ˜ì¤€ ì‚¬ì´ì˜ ê´€ê³„ëŠ” ë°ì´í„°ë² ì´ìŠ¤ ì‹œìŠ¤í…œ ë° ì‚¬ìš©ìì˜ ìš”êµ¬ ì‚¬í•­ì— ë”°ë¼ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
íŠ¹íˆ íŠ¸ë¦¬ê±°ë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” ê²©ë¦¬ ìˆ˜ì¤€ê³¼ ì¼ê´€ì„±ì„ ê³ ë ¤í•˜ì—¬ ë°ì´í„°ì˜ ì •í™•ì„±ê³¼ ì•ˆì •ì„±ì„ ìœ ì§€í•˜ëŠ”ë° ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.

### íŠ¸ëœì­ì…˜ê³¼ dml event triggerì˜ ê´€ê³„ì •ì˜

íŠ¸ë¦¬ê±°ë¥¼ í™œì„±í™”ì‹œí‚¨ íŠ¸ëœì­ì…˜ê³¼ í™œì„±í™”ëœ íŠ¸ëœì­ì…˜ì€
ìµœì´ˆ íŠ¸ë¦¬ê±°ë¥¼ í™œì„±í™”ì‹œí‚¨ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ë¬¶ì¸ë‹¤.

ë°˜ëŒ€ë¡œ íŠ¸ë¦¬ê±°ë¥¼ í†µí•´ í™œì„±í™”ëœ íŠ¸ëœì­ì…˜ì—ì„œ ì—ëŸ¬ê°€ ë‚  ê²½ìš°
ì£¼ì²´ê°€ ë˜ëŠ” íŠ¸ë¦¬ê±°ë¥¼ í™œì„±í™”ì‹œí‚¨ íŠ¸ëœì­ì…˜ê¹Œì§€ ì „ë¶€ rollbackëœë‹¤.

```seudo
if (íŠ¸ë¦¬ê±°ë¥¼ í™œì„±í™”ì‹œí‚¨ íŠ¸ëœì­ì…˜ì—ì„œ ì—ëŸ¬ê°€ ë‚¬ì„ ê²½ìš°) or (í™œì„±í™”ëœ íŠ¸ëœì­ì…˜ì—ì„œ ì—ëŸ¬ê°€ ë‚  ê²½ìš°):
	failure.rollback;
if rollback:	
	success.rollback;
if commit:
	success.commit;
```

ex) íŠ¹ì • í…Œì´ë¸”ì— insertì‹œ ë™ì‘í•˜ëŠ” triggerì— ì˜í•´ ë˜ë‹¤ë¥¸ dmlì´ ë°œìƒí•  ê²½ìš°
eventë¥¼ ìœ ë°œì‹œí‚¨ dmlì˜ íŠ¸ëœì­ì…˜ì— í¬í•¨ëœë‹¤.


	DML								event on trigger1 	event on triggerN
	<transaction>
										DML
																				DML
	
	</transaction>
	
	when failure
		rollback(DML, trigger1.DML, triggerN.DML);
	when success
		when rollback
			rollback(DML, trigger1.DML, triggerN.DML);
		when commit
			commit(DML, trigger1.DML, triggerN.DML);

---
âœ… trigger bodyì—ëŠ” commit/rollbackì„ í¬í•¨í•  ìˆ˜ ì—†ë‹¤.
