[toc]

# Trigger

[oracle trigger documentation](https://docs.oracle.com/cd/E17781_01/appdev.112/e18147/tdddg_triggers.htm#TDDDG51000)

ì–´ë–¤ í–‰ìœ„ ì „/í›„/ëŒ€ì‹  ìˆ˜í–‰ë˜ëŠ” ì‘ì—… ì •ì˜

> ì ‘ì†ê¸°ë¡: ì ‘ì† í›„ (username, ip, host)ì„ insert
> ì ‘ì†í•´ì œê¸°ë¡: ì ‘ì†í•´ì œ ì „ (username, ip, host)ì„ insert

í–‰ìœ„ ì¢…ë¥˜ì— ë”°ë¼: dml, ddl, database íŠ¸ë¦¬ê±°ë¡œ êµ¬ë¶„
selectì˜ ê²½ìš°, ì§ì ‘ì ìœ¼ë¡œ triggering í•  ìˆ˜ì—†ì–´ ê°„ì ‘ì ìœ¼ë¡œ trigger í•´ì•¼í•¨.

ğŸ’¥ì£¼ì˜ì‚¬í•­
function/triggerë¥¼ í†µí•´ ìˆ˜ì •ì‹œ old valueì™€ new valueë¥¼ êµ¬ë¶„í•˜ì§€ ì•Šìœ¼ë©´
dml ìˆ˜í–‰ ë¶ˆê°€(ê°™ì€ ë°ì´í„°ë¥¼ ì—´ì–´ë‘ê³  ìˆ˜ì •í•˜ëŠ” í–‰ìœ„ì— ëŒ€í•´ ì—ëŸ¬ ì²˜ë¦¬)

## syntax

```sql
create [or replace] trigger íŠ¸ë¦¬ê±°ëª… 
timing 
	before|after|instead of [event1 or event2 or event3 â€¦ ] 
	on {table_name|view_name|schema|database} 
[referencing old as old | new as new] 
[for each row [when ( condition ) ] ] 
trigger_body
;
```

## management

### 1. describe

```sql
select * from dba_objects where object_type = 'TRIGGER';
select * from dba_triggers;
```

### 2. on/off a single trigger

```sql
alter trigger $TRIGGER_NAME disable;
alter trigger $TRIGGER_NAME enable;
```

### 3. on/off triggers on a single table

```sql
alter table $TABLE_NAME disable all triggers;
alter table $TABLE_NAME enable all triggers;
```

## usage

### 1. database event trigger

#### logon

```sql
-- ìœ ì € ì •ë³´ ì¡°íšŒ
select sys_context('USERENV', 'IP_ADDRESS')   as ip,
			 sys_context('USERENV', 'SESSIONID')    as sessionid,
			 sys_context('USERENV', 'HOST')         as host,
			 sys_context('USERENV', 'TERMINAL')     as device
	from dual;
	
-- í…Œì´ë¸” ìƒì„±
create table scott.log_on
( userid    varchar2(64),
  ip_addr   varchar2(64),
  host      varchar2(64),
  created   timestamp);
			 
-- log on íŠ¸ë¦¬ê±° ìƒì„±
create or replace trigger t_loggon
after logon on database
begin
	insert into log_on values (
  user,
  sys_context('USERENV', 'IP_ADDRESS'),
  sys_context('USERENV', 'TERMINAL'),
  systimestamp);
  commit;
end;
/
```

#### logon/off

> log_on: insert
> log_off: update

```sql
-- ìœ ì € ì •ë³´ ì¡°íšŒ
select sys_context('USERENV', 'IP_ADDRESS')   as ip,
			 sys_context('USERENV', 'SESSIONID')    as sessionid,
			 sys_context('USERENV', 'HOST')         as host,
			 sys_context('USERENV', 'TERMINAL')     as device
	from dual;

drop table log_on_off purge;
create table log_on_off
( session_id    number,
  userid        varchar2(64),
  ip            varchar2(64),
  host          varchar2(64),
  device        varchar2(64),
  joined        timestamp,
  leaved        timestamp
);

create or replace trigger t_loggon
after logon on database
begin
	insert into log_on_off (
  session_id,
  userid,
  ip,
  host,
  device,
  joined)
  values (
  sys_context('USERENV', 'SESSIONID'),
  user,
  sys_context('USERENV', 'IP_ADDRESS'),
  sys_context('USERENV', 'HOST'),
  sys_context('USERENV', 'TERMINAL'),
  systimestamp
  );
  commit;
end;
/

create or replace trigger t_loggoff
before logoff on database
begin
	update log_on_off
     set leaved = systimestamp
   where session_id = sys_context('USERENV', 'SESSIONID');
  commit;
end;
/
select *
  from log_on_off;
```

#### access authorization trigger

```sql
select username,
       created
  from dba_users
 where default_tablespace = 'USERS'
   and trunc(sysdate - created) = 0
 order by created;

drop user black_list_1_no_create_session;
drop user black_list_2_privilege;
create user black_list_1_no_create_session identified by oracle;
create user black_list_2_privilege identified by oracle;
--grant create session to black_list_1_no_create_session;
grant create session to black_list_2_privilege;

drop trigger t_loggon;
drop trigger t_loggoff;
drop table log_on_off purge;

create table log_on_off
( session_id    number,
  userid        varchar2(64),
  ip            varchar2(64),
  host          varchar2(64),
  device        varchar2(64),
 	status				varchar2(8),
  joined        timestamp,
  leaved        timestamp
);

create or replace trigger t_loggon
after logon on database
begin
	if upper(user) in (
    'BLACK_LIST_1_NO_CREATE_SESSION', 
    'BLACK_LIST_2_PRIVILEGE'
  ) then
    insert into log_on_off (session_id, userid, ip, host, device, status, joined)
    values (sys_context('USERENV', 'SESSIONID'),
				    user,
            sys_context('USERENV', 'IP_ADDRESS'),
            sys_context('USERENV', 'HOST'),
            sys_context('USERENV', 'TERMINAL'),
            'DENIED',
            systimestamp);
    commit;
  	raise_application_error(-20403, 'ìŠ¹ì¸ë˜ì§€ ì•Šì€ ì‚¬ìš©ìì…ë‹ˆë‹¤.('||upper(user)||')');
  else
  	insert into log_on_off (session_id, userid, ip, host, device, status, joined)
    values (sys_context('USERENV', 'SESSIONID'),
            user,
            sys_context('USERENV', 'IP_ADDRESS'),
            sys_context('USERENV', 'HOST'),
            sys_context('USERENV', 'TERMINAL'),
            'SUCCESS',
            systimestamp);
    commit;
    dbms_output.put_line('ì ‘ì†ì´ í—ˆê°€ë˜ì—ˆìŠµë‹ˆë‹¤. welcome');
  end if;
end;
/

create or replace trigger t_loggoff
before logoff on database
begin
	update log_on_off
     set leaved = systimestamp
   where session_id = sys_context('USERENV', 'SESSIONID');
  commit;
end;
/

select *
  from log_on_off
 order by joined desc;
```

### 2. dml event trigger

íŠ¹ì • í…Œì´ë¸”ì— ëŒ€í•´ dmlë°œìƒì‹œ dmlì— ëŒ€í•œ ê¸°ë¡ì„ í•˜ëŠ” íŠ¸ë¦¬ê±° ì‘ì„±

```sql
drop table student2 purge;
drop table delete_std2_log purge;
drop table update_std2_log purge;
drop table insert_std2_log purge;

create table student2 as select * from student;
create table delete_std2_log as select s.*, sysdate as processed from student s where 1=2; 
create table update_std2_log as select s.*, sysdate as processed from student s where 1=2;
create table insert_std2_log as select s.*, sysdate as processed from student s where 1=2;

alter table update_std2_log add type char(3);

select * from delete_std2_log;
select * from update_std2_log;
select * from insert_std2_log;
```

#### delete

```sql
create or replace trigger delete_std2
after delete on student2
for each row
begin
	insert into delete_std2_log
	values(
  :old.studno, 
  :old.name, :old.id, :old.grade, :old.jumin,
  :old.birthday, :old.tel, :old.height, :old.weight,
  :old.deptno1, :old.deptno2, :old.profno, :old.hakjum,
  sysdate
  );
end;
/

delete from student2
 where studno = 9411;
commit;

select *
  from delete_std2_log;
```

#### update

```sql
create or replace trigger update_before_std2
before update on student2
for each row
begin
	insert into update_std2_log
	values(
  :old.studno, 
  :old.name, :old.id, :old.grade, :old.jumin,
  :old.birthday, :old.tel, :old.height, :old.weight,
  :old.deptno1, :old.deptno2, :old.profno, :old.hakjum,
  sysdate, 'OLD'
  );
end;
/

create or replace trigger update_after_std2
after update on student2
for each row
begin
	insert into update_std2_log
	values(
  :new.studno, 
  :new.name, :new.id, :new.grade, :new.jumin,
  :new.birthday, :new.tel, :new.height, :new.weight,
  :new.deptno1, :new.deptno2, :new.profno, :new.hakjum,
  sysdate, 'NEW'
  );
end;
/

update student2
   set name = name||'TEST'
 where studno = 9413;
 commit;
 
select *
  from update_std2_log;
```

#### insert

```sql
create or replace trigger insert_std2
after insert on student2
for each row
begin
	insert into insert_std2_log
	values(
  :new.studno, 
  :new.name, :new.id, :new.grade, :new.jumin,
  :new.birthday, :new.tel, :new.height, :new.weight,
  :new.deptno1, :new.deptno2, :new.profno, :new.hakjum,
  sysdate
  );
end;
/

insert into student2
select studno,
       name,
       id,
       grade,
       jumin,
       birthday,
       tel,
       height,
       weight,
       deptno1,
       deptno2,
       profno,
       hakjum
  from delete_std2_log where studno = 9412;
commit;

select *
  from insert_std2_log;
```

#### I/U/D

```sql
-- pre
drop table student3 purge;
create table student3 as select * from student;

drop table audit_log_student3 purge;
create table audit_log_student3 as
select 1 as audit_id,
			 'CREATE' as audit_type,
       sysdate as audit_processed, 
       s.*
  from student s
 where 1=2;
select * from audit_log_student3;

drop sequence seq_audit_log_student3;
create sequence seq_audit_log_student3;

-- define trigger
create or replace trigger trg_audit_at_student3
after insert or update or delete on student3
for each row
begin
	if INSERTING then    
    insert into audit_log_student3
    values(seq_audit_log_student3.nextval, 'INSERT', sysdate,
           :new.studno, :new.name, :new.id, :new.grade, :new.jumin, :new.birthday, :new.tel, :new.height, :new.weight, :new.deptno1, :new.deptno2, :new.profno, :new.hakjum);
  elsif UPDATING then    
    insert into audit_log_student3
    values(seq_audit_log_student3.nextval, 'UPDATE', sysdate,
           :new.studno, :new.name, :new.id, :new.grade, :new.jumin, :new.birthday, :new.tel, :new.height, :new.weight, :new.deptno1, :new.deptno2, :new.profno, :new.hakjum);
  elsif DELETING then    
    insert into audit_log_student3
    values(seq_audit_log_student3.nextval, 'DELETE', sysdate,
           :old.studno, :old.name, :old.id, :old.grade, :old.jumin, :old.birthday, :old.tel, :old.height, :old.weight, :old.deptno1, :old.deptno2, :old.profno, :old.hakjum);
  else
    dbms_output.put_line('this code is not reachable.');
  end if;
  
end;
/

-- trigger test
insert into student3 values (9999, 'NAME', 'RETURNTRUE', 4, '7510231901813', sysdate, '055)381-2158', 180, 72, 101, 201, 1001, null);
commit;
update student3
   set name = 'TEST'
 where studno = 9999;
commit;
delete from student3
 where studno = 9999;
commit;

-- check
select *
   from audit_log_student3
 order by audit_processed asc;
```



