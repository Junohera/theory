# Silence DML & Redo Log Buffer

Redo Log Buffer에 기록하지 않는 경우

1. Direct Load
   1. SQL Loader
   2. insert hint(`insert /*+ append */`)
2. nologging option
   1. table(테이블 노로깅 DML작업의 경우, 제한적으로 redo log에 기록 -> 다른 케이스에 비해 다소 느릴 수 밖에 없음)
   2. index

---

## Test Case

- [ ] nologging_test1
  just insert
- [ ] nologging_test2
  insert with append hint
- [ ] nologging_test3
  just insert in nologging table
- [ ] nologging_test4
  insert with append hint in nologging table

## Try

### 0. tablespace

```sql
create tablespace nologging_test
			 datafile '/oracle12/app/oracle/oradata/db1/nologging_test_01.dbf' size 1000m;
			 
select * from dba_tablespaces;

-- redo log file 확인
SQL> SELECT name, value FROM   v$sysstat WHERE  name in ('redo size', 'redo writes', 'redo blocks written');

NAME                                                                  VALUE
---------------------------------------------------------------- ----------
redo size                                                        2253926804
redo writes                                                            3041
redo blocks written                                                 4563155
```

### 1. nologging_test1

> just insert

```sql
drop table nologging_test1 purge;
create table nologging_test1 (
  a number, 
  b varchar2(10)
)
tablespace nologging_test;

begin 
for i in 1..5000000 loop
  insert into nologging_test1
  values (i, 'AAAA');
end loop;
commit;
end;
/

-- 실제 redo log 사용 현황 
SELECT name,
       value
FROM   v$sysstat
WHERE  name in ('redo size',              -- redo buffer 할당량
                'redo writes' ,           -- equals the number of blocks per write.
                'redo blocks written');   -- 실제 redo file에 기록되는 disk IO
```

### 2. nologging_test2

> insert with append hint

```sql
drop table nologging_test2 purge;
create table nologging_test2 (
  a number, 
  b varchar2(10)
)
tablespace nologging_test;

begin 
for i in 1..5000000 loop
  insert /*+ append */ into nologging_test2
  values (i, 'AAAA');
end loop;
commit;
end;
/

-- 실제 redo log 사용 현황 
SELECT name,
       value
FROM   v$sysstat
WHERE  name in ('redo size',              -- redo buffer 할당량
                'redo writes' ,           -- equals the number of blocks per write.
                'redo blocks written');   -- 실제 redo file에 기록되는 disk IO
```

### 3. nologging_test3

> just insert in nologging table

```sql
drop table nologging_test3 purge;
create table nologging_test3 (
  a number, 
  b varchar2(10)
)
tablespace nologging_test
nologging;

begin 
for i in 1..5000000 loop
  insert into nologging_test3
  values (i, 'AAAA');
end loop;
commit;
end;
/

-- 실제 redo log 사용 현황 
SELECT name,
       value
FROM   v$sysstat
WHERE  name in ('redo size',              -- redo buffer 할당량
                'redo writes' ,           -- equals the number of blocks per write.
                'redo blocks written');   -- 실제 redo file에 기록되는 disk IO
```

### 4. nologging_test4

> insert with append hint in nologging table

```sql
drop table nologging_test4 purge;
create table nologging_test4 (
  a number, 
  b varchar2(10)
)
tablespace nologging_test
nologging;

begin 
for i in 1..5000000 loop
  insert /*+ append */ into nologging_test4
  values (i, 'AAAA');
end loop;
commit;
end;
/

-- 실제 redo log 사용 현황 
SELECT name,
       value
FROM   v$sysstat
WHERE  name in ('redo size',              -- redo buffer 할당량
                'redo writes' ,           -- equals the number of blocks per write.
                'redo blocks written');   -- 실제 redo file에 기록되는 disk IO
```

