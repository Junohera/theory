**Q**

```sql
DB 운영중에 대용량 insert 요청이 들어왔다.
빠르게 insert하지 않으면 계속해서 업무 손실이 발생하는 상황이다.
DBA는 direct mode로 insert 수행을 고려중이다 (insert /*+ append*/ ...)
하지만 이 경우 redo log에 기록되지 않아 위험한 상황에 빠지게 될 수 있는데
과연 DBA의 최선은?
```

---

**A**: **Best**🤩

- **insert 수행 이후 backup**(여유가 있다면 insert 수행 이전 backup)

  - 상세 내용: 일반적인 백업의 흐름은

    1. **가장 최근 백업본으로 시점복구**
    2. **1번의 시점 이후의 내용은 아카이브로그로 덧붙임**

    위의 2가지로 진행되는데 그러다보니 1번을 수행하는 시점을 대규모 트랜잭션 이후로 잡아두면 사후 장애가 또 발생하여도 대처가 가능해짐.

---

A: 모를 때🤢

**급한불끄고 사후 시점복구 필요가 생겼을 때의 단점을 커버하는 방향**

1. direct mode로 대용량 insert 수행
   1. DB 복제본 생성
      1. DB 복제본에서
         1. 대용량 insert 수행 전, 가장 마지막 시점으로 복구
         2. redo log에 기록되도록 direct mode를 사용하지 않고, 대용량 insert 수행
         3. A와 A`의 redo 또는 archive log의 gap을 비교하여 별도 보관
         4. 시점복구가 필요할 경우 3번의 내용들을 시점복구 후, 추가 조치
   2. Table 복제본 생성
      1. CTAS를 활용해 direct mode를 사용하지 않고, 복제 테이블 생성
      2. A`를 A로 스위칭
   3. merge 구문 활용
      1. insert | update가 포함된 merge 구문을 direct mode를 사용하지않고, 로그에 기록되도록 수행
      2. 대신 parallel 힌트 사용
         `alter session enable parallel dml;`

**미리 예상하여 사전에 준비가 되어있는 상태에서 정공법**

> 평소 대규모 요청에 들어올 것을 감안하여
> 하드웨어 자원과 소프트웨어인 DBMS에 할당된 자원을 조사하여
> 안정성을 유지하면서 최대 퍼포먼스를 발휘할 수 있는 최대 가용성에 부합하는 수치적 범위를 준비
>
> 위에서 정한 수치를 활용한 `대규모 transaction 모드`(A)와 `평시 서비스 운용 모드`(B)를 구분하여
> 각각의 모드로 변경하도록 파라미터 및 명령어를 수행하는 스크립트를 생성해둔다.

- 조건

  1. 서비스 안정성 유지
     1. 정합성 유지
     2. 서비스 운영중인 상태에서의 나머지 트랜잭션도 정상 수행

  1. 최대 퍼포먼스 
     1. 손실을 최소화할 수 있는 속도

- B모드 준비

  - A모드에서 다시 B모드로 복구하기 위한 시나리오에 따른 스크립트 작성

- A모드 준비

  - B모드에서 A모드로 변경하기 위한 시나리오에 따른 스크립트 작성
    - 가용되는 하드웨어의 자원을 최대한 활용가능하도록 DBMS의 스펙업(ex: 메모리, cpu)
    - large_pool_size 조정
    - 자동 메모리 관리를 사용하지 않고, manual로 DBMS의 전반적인 메모리를 조정

- 사건이 발생하기 전 사전에 수행절차를 내부적으로 테스트

  - B -> A 모드 전환
  - parallel을 사용한 대규모 transaction
  - A -> B 모드 전환

- 사건 발생시 검증된 시나리오에 따라 적용

  

